<?php

namespace Pumukit\SchemaBundle\Repository;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ODM\MongoDB\Query\Builder;
use Doctrine\ODM\MongoDB\Repository\DocumentRepository;
use MongoDB\BSON\ObjectId;
use MongoDB\BSON\Regex;
use Pumukit\SchemaBundle\Document\EmbeddedTag;
use Pumukit\SchemaBundle\Document\MultimediaObject;
use Pumukit\SchemaBundle\Document\Series;
use Pumukit\SchemaBundle\Document\SeriesType;
use Pumukit\SchemaBundle\Document\Tag;
use Pumukit\SchemaBundle\Document\User;

/**
 * SeriesRepository.
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class SeriesRepository extends DocumentRepository
{
    /**
     * Find series by tag id.
     *
     * @param EmbeddedTag|Tag $tag
     * @param array           $sort
     * @param int             $limit
     * @param int             $page
     *
     * @return mixed
     */
    public function findWithTag($tag, $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->createBuilderWithTag($tag, $sort);

        $qb = $this->addLimitToQueryBuilder($qb, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Create QueryBuilder to find series by tag id.
     *
     * @param Tag   $tag
     * @param array $sort
     */
    public function createBuilderWithTag($tag, $sort = []): Builder
    {
        $referencedSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findSeriesFieldWithTag($tag);

        $qb = $this->createQueryBuilder()->field('_id')->in($referencedSeries->toArray());

        return $this->addSortToQueryBuilder($qb, $sort);
    }

    /**
     * Find one series with tag.
     *
     * @param EmbeddedTag|Tag $tag
     *
     * @return array|object|null
     */
    public function findOneWithTag($tag)
    {
        $referencedOneSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findOneSeriesFieldWithTag($tag);

        return $this->createQueryBuilder()->field('_id')->equals($referencedOneSeries)->getQuery()->getSingleResult();
    }

    /**
     * Find series with any tag.
     *
     * @param array $tags
     * @param array $sort
     * @param int   $limit
     * @param int   $page
     */
    public function findWithAnyTag($tags, $sort = [], $limit = 0, $page = 0): ArrayCollection
    {
        $referencedSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findSeriesFieldWithAnyTag($tags);

        $qb = $this->createQueryBuilder()->field('_id')->in($referencedSeries->toArray());

        $qb = $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Find series with all tags.
     *
     * @param array $tags
     * @param array $sort
     * @param int   $limit
     * @param int   $page
     */
    public function findWithAllTags($tags, $sort = [], $limit = 0, $page = 0): ArrayCollection
    {
        $referencedSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findSeriesFieldWithAllTags($tags);

        $qb = $this->createQueryBuilder()->field('_id')->in($referencedSeries->toArray());

        $qb = $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Find one series with all tags.
     *
     * @param array $tags
     *
     * @return array|object|Series|null
     */
    public function findOneWithAllTags($tags)
    {
        $referencedOneSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findOneSeriesFieldWithAllTags($tags);

        return $this->createQueryBuilder()->field('_id')->equals($referencedOneSeries)->getQuery()->getSingleResult();
    }

    /**
     * Find series without tag.
     *
     * @param EmbeddedTag|Tag $tag
     * @param array           $sort
     * @param int             $limit
     * @param int             $page
     */
    public function findWithoutTag($tag, $sort = [], $limit = 0, $page = 0): ArrayCollection
    {
        $referencedSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findSeriesFieldWithTag($tag);

        $qb = $this->createQueryBuilder()->field('_id')->notIn($referencedSeries->toArray());

        $qb = $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Find one series without tag.
     *
     * @param EmbeddedTag|Tag $tag
     *
     * @return array|object|null
     */
    public function findOneWithoutTag($tag)
    {
        $referencedSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findSeriesFieldWithTag($tag);

        return $this->createQueryBuilder()->field('_id')->notIn($referencedSeries->toArray())->getQuery()->getSingleResult();
    }

    /**
     * Find series without all tags.
     *
     * @param mixed $tags
     * @param array $sort
     * @param mixed $limit
     * @param mixed $page
     *
     * @return mixed
     */
    public function findWithoutAllTags($tags, $sort = [], $limit = 0, $page = 0)
    {
        $referencedSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findSeriesFieldWithAllTags($tags);

        $qb = $this->createQueryBuilder()->field('_id')->notIn($referencedSeries->toArray());

        $qb = $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Find series by pic id.
     *
     * @param string $picId
     *
     * @return array|object|null
     */
    public function findByPicId($picId)
    {
        return $this->createQueryBuilder()->field('pics._id')->equals(new ObjectId($picId))->getQuery()->getSingleResult();
    }

    /**
     * Find series by person id.
     *
     * @param string $personId
     *
     * @return mixed
     */
    public function findSeriesByPersonId($personId)
    {
        $repoMmobj = $this->getDocumentManager()->getRepository(MultimediaObject::class);

        $referencedSeries = $repoMmobj->findSeriesFieldByPersonId($personId);

        return $this->createQueryBuilder()->field('_id')->in($referencedSeries->toArray())->getQuery()->execute();
    }

    /**
     * @param \MongoId|string $personId
     */
    public function createBuilderByPersonIdAndRoleCod($personId, string $roleCod, array $sort = [], int $limit = 0, int $page = 0): Builder
    {
        $repoMmobj = $this->getDocumentManager()->getRepository(MultimediaObject::class);
        $referencedSeries = $repoMmobj->findSeriesFieldByPersonIdAndRoleCod($personId, $roleCod);

        return $this->createQueryBuilder()->field('_id')->in($referencedSeries->toArray());
    }

    /**
     * @param \MongoId|string $personId
     *
     * @return mixed
     */
    public function findByPersonIdAndRoleCod($personId, string $roleCod, array $sort = [], int $limit = 0, int $page = 0)
    {
        $qb = $this->createBuilderByPersonIdAndRoleCod($personId, $roleCod, $sort, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Find series by person id and role cod or groups.
     *
     * @param \MongoId|string $personId
     * @param string          $roleCod
     * @param array           $groups
     *
     * @return mixed
     */
    public function findByPersonIdAndRoleCodOrGroups($personId, $roleCod, $groups)
    {
        $repoMmobj = $this->getDocumentManager()->getRepository(MultimediaObject::class);
        $referencedSeries = $repoMmobj->findSeriesFieldByPersonIdAndRoleCodOrGroups($personId, $roleCod, $groups);

        return $this->createQueryBuilder()->field('_id')->in($referencedSeries->toArray())->getQuery()->execute();
    }

    /**
     * Find series by person id and role cod or groups sorted Query Builder.
     *
     * @param \MongoId|string $personId
     * @param string          $roleCod
     * @param array           $groups
     * @param array           $sort
     * @param int             $limit
     * @param int             $page
     *
     * @return Builder
     */
    public function findByPersonIdAndRoleCodOrGroupsSortedQueryBuilder($personId, $roleCod, $groups, $sort = [], $limit = 0, $page = 0)
    {
        $repoMmobj = $this->getDocumentManager()->getRepository(MultimediaObject::class);
        $referencedSeries = $repoMmobj->findSeriesFieldByPersonIdAndRoleCodOrGroups($personId, $roleCod, $groups);

        $qb = $this->createQueryBuilder()->field('_id')->in($referencedSeries->toArray());

        return $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);
    }

    /**
     * Find series by person id and role cod or groups sorted Query.
     *
     * @param \MongoId|string $personId
     * @param string          $roleCod
     * @param array           $groups
     * @param array           $sort
     * @param int             $limit
     * @param int             $page
     *
     * @return \Doctrine\MongoDB\Query\Query
     */
    public function findByPersonIdAndRoleCodOrGroupsSortedQuery($personId, $roleCod, $groups, $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->findByPersonIdAndRoleCodOrGroupsSortedQueryBuilder($personId, $roleCod, $groups, $sort, $limit, $page);

        return $qb->getQuery();
    }

    /**
     * Find series by person id and role cod or groups sorted.
     *
     * @param \MongoId|string $personId
     * @param string          $roleCod
     * @param array           $groups
     * @param array           $sort
     * @param int             $limit
     * @param int             $page
     *
     * @return mixed
     */
    public function findByPersonIdAndRoleCodOrGroupsSorted($personId, $roleCod, $groups, $sort = [], $limit = 0, $page = 0)
    {
        $query = $this->findByPersonIdAndRoleCodOrGroupsSortedQuery($personId, $roleCod, $groups, $sort, $limit, $page);

        return $query->execute();
    }

    /**
     * Find series with given series type.
     *
     * @throws \Doctrine\ODM\MongoDB\MongoDBException
     *
     * @return mixed
     */
    public function findBySeriesType(SeriesType $series_type)
    {
        return $this->createQueryBuilder()->field('series_type')->references($series_type)->getQuery()->execute();
    }

    /**
     * Count number of series in the repo.
     *
     * @return mixed
     */
    public function count()
    {
        return $this->createQueryBuilder()->count()->getQuery()->execute();
    }

    /**
     * Count number of series in the repo.
     *
     * @return mixed
     */
    public function countPublic()
    {
        return $this->getDocumentManager()->getRepository(MultimediaObject::class)->createStandardQueryBuilder()->distinct('series')->getQuery()->execute()->count();
    }

    /**
     * Find series with tag and series type.
     *
     * @param Tag    $tag
     * @param object $seriesType
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return mixed
     */
    public function findWithTagAndSeriesType($tag, $seriesType, $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->createBuilderWithTagAndSeriesType($tag, $seriesType, $sort);

        $qb = $this->addLimitToQueryBuilder($qb, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Create QueryBuilder to find series with tag and series type.
     *
     * @param Tag    $tag
     * @param object $seriesType
     * @param array  $sort
     *
     * @return mixed
     */
    public function createBuilderWithTagAndSeriesType($tag, $seriesType, $sort = [])
    {
        $referencedSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findSeriesFieldWithTag($tag);

        $qb = $this->createQueryBuilder()->field('_id')->in($referencedSeries->toArray())->field('series_type')->references($seriesType);

        return $this->addSortToQueryBuilder($qb, $sort);
    }

    /**
     * Find series with the same propertyName.
     *
     * @param string $propertyName
     * @param string $propertyValue
     *
     * @return array|object|null
     */
    public function findOneBySeriesProperty($propertyName, $propertyValue)
    {
        return $this->createQueryBuilder()->field('properties.'.$propertyName)->equals($propertyValue)->getQuery()->getSingleResult();
    }

    /**
     * Find by EmbeddedBroadcast type Query Builder.
     *
     * @param string $type
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return Builder
     */
    public function findByEmbeddedBroadcastTypeQueryBuilder($type = '', $sort = [], $limit = 0, $page = 0)
    {
        $repoMmobj = $this->getDocumentManager()->getRepository(MultimediaObject::class);
        $referencedSeries = $repoMmobj->findSeriesFieldByEmbeddedBroadcastType($type);

        $qb = $this->createQueryBuilder()->field('_id')->in($referencedSeries->toArray());

        return $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);
    }

    /**
     * Find by EmbeddedBroadcast type Query.
     *
     * @param string $type
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return \Doctrine\MongoDB\Query\Query
     */
    public function findByEmbeddedBroadcastTypeQuery($type = '', $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->findByEmbeddedBroadcastTypeQueryBuilder($type, $sort, $limit, $page);

        return $qb->getQuery();
    }

    /**
     * Find by EmbeddedBroadcast type.
     *
     * @param string $type
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return mixed
     */
    public function findByEmbeddedBroadcastType($type = '', $sort = [], $limit = 0, $page = 0)
    {
        $query = $this->findByEmbeddedBroadcastTypeQuery($type, $sort, $limit, $page);

        return $query->execute();
    }

    /**
     * Find by embedded broadcast type and groups Query Builder.
     *
     * @param string $type
     * @param array  $groups
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return Builder
     */
    public function findByEmbeddedBroadcastTypeAndGroupsQueryBuilder($type = '', $groups = [], $sort = [], $limit = 0, $page = 0)
    {
        $repoMmobj = $this->getDocumentManager()->getRepository(MultimediaObject::class);
        $referencedSeries = $repoMmobj->findSeriesFieldByEmbeddedBroadcastTypeAndGroups($type, $groups);

        $qb = $this->createQueryBuilder()->field('_id')->in($referencedSeries->toArray());

        return $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);
    }

    /**
     * Find by embedded broadcast type and groups Query.
     *
     * @param string $type
     * @param array  $groups
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return \Doctrine\MongoDB\Query\Query
     */
    public function findByEmbeddedBroadcastTypeAndGroupsQuery($type = '', $groups = [], $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->findByEmbeddedBroadcastTypeAndGroupsQueryBuilder($type, $groups, $sort, $limit, $page);

        return $qb->getQuery();
    }

    /**
     * Find by embedded broadcast type and groups.
     *
     * @param string $type
     * @param array  $groups
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return mixed
     */
    public function findByEmbeddedBroadcastTypeAndGroups($type = '', $groups = [], $sort = [], $limit = 0, $page = 0)
    {
        $query = $this->findByEmbeddedBroadcastTypeAndGroupsQuery($type, $groups, $sort, $limit, $page);

        return $query->execute();
    }

    /**
     * Find by title with locale query builder.
     *
     * @param string $title
     * @param string $locale
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return Builder
     */
    public function findByTitleWithLocaleQueryBuilder($title = '', $locale = 'en', $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->createQueryBuilder()->field('title.'.$locale)->equals(new Regex($title, 'i'));

        return $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);
    }

    /**
     * Find by title with locale query.
     *
     * @param string $title
     * @param string $locale
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return \Doctrine\MongoDB\Query\Query
     */
    public function findByTitleWithLocaleQuery($title = '', $locale = 'en', $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->findByTitleWithLocaleQueryBuilder($title, $locale, $sort, $limit, $page);

        return $qb->getQuery();
    }

    /**
     * Find by title with locale.
     *
     * @param string $title
     * @param string $locale
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return mixed
     */
    public function findByTitleWithLocale($title = '', $locale = 'en', $sort = [], $limit = 0, $page = 0)
    {
        $query = $this->findByTitleWithLocaleQuery($title, $locale, $sort, $limit, $page);

        return $query->execute();
    }

    /**
     * @param User $user
     * @param bool $onlyAdminSeries
     *
     * @throws \Doctrine\ODM\MongoDB\MongoDBException
     *
     * @return array
     */
    public function findUserSeries($user, $onlyAdminSeries = false)
    {
        $dm = $this->getDocumentManager();

        // Find user series (properties.owners)
        $seriesCollection = $dm->getDocumentCollection(Series::class);

        if (($permissionProfile = $user->getPermissionProfile()) && $permissionProfile->isGlobal() && !$onlyAdminSeries) {
            $group = ['_id' => ['id' => '$_id', 'title' => '$title']];
            $command = [['$group' => $group]];

            return $seriesCollection->aggregate($command, ['cursor' => []])->toArray();
        }

        $match = [];
        $match['properties.owners'] = ['$in' => [$user->getId()]];
        $group = ['_id' => ['id' => '$_id', 'title' => '$title']];

        $command = [['$match' => $match], ['$group' => $group]];
        $aSeries = $seriesCollection->aggregate($command, ['cursor' => []])->toArray();

        // Find mmo user groups
        $mmoCollection = $dm->getDocumentCollection(MultimediaObject::class);

        $groups = [];
        foreach ($user->getGroups() as $group) {
            $groups[] = new ObjectId($group->getId());
        }

        $match = [];
        $unwind = ['$unwind' => '$groups'];
        $match['groups'] = ['$in' => $groups];
        $group = ['_id' => ['id' => '$series', 'title' => '$seriesTitle']];

        $command = [$unwind, ['$match' => $match], ['$group' => $group]];
        $aMMO = $mmoCollection->aggregate($command, ['cursor' => []])->toArray();

        $aSeries = array_merge($aSeries, $aMMO);
        usort($aSeries, function ($a, $b) {
            return ($a['_id']['title'] <= $b['_id']['title']) ? -1 : 1;
        });

        return $aSeries;
    }

    /**
     * Count number of multimedia objects by series.
     *
     * @deprecated Use MultimediaObjectRepository::countMmobjsBySeries
     *
     * @param array $seriesList A key/value hash where the key is the series id (string) and the value is the count
     *
     * @return mixed
     */
    public function countMmobjsBySeries($seriesList = [])
    {
        return $this->getDocumentManager()
            ->getRepository(MultimediaObject::class)
            ->countMmobjsBySeries($seriesList)
        ;
    }

    /**
     * @return mixed
     */
    public function getMultimediaObjects(Series $series)
    {
        return $this->getDocumentManager()
            ->getRepository(MultimediaObject::class)
            ->findWithoutPrototype($series)
        ;
    }

    /**
     * @return mixed
     */
    public function countMultimediaObjects(Series $series)
    {
        return $this->getDocumentManager()
            ->getRepository(MultimediaObject::class)
            ->countWithoutPrototype($series)
        ;
    }

    /**
     * Add limit (and page) to Query Builder.
     *
     * @param Builder $qb
     * @param int     $limit
     * @param int     $page
     *
     * @return mixed
     */
    private function addLimitToQueryBuilder($qb, $limit = 0, $page = 0)
    {
        if ($limit > 0) {
            $qb->limit($limit)->skip($limit * $page);
        }

        return $qb;
    }

    /**
     * Add sort to Query Builder.
     *
     * @param Builder $qb
     * @param array   $sort
     *
     * @return mixed
     */
    private function addSortToQueryBuilder($qb, $sort = [])
    {
        if (0 !== count($sort)) {
            $qb->sort($sort);
        }

        return $qb;
    }

    /**
     * Add sort and limit (and page) to Query Builder.
     *
     * @param Builder $qb
     * @param array   $sort
     * @param int     $limit
     * @param int     $page
     *
     * @return mixed
     */
    private function addSortAndLimitToQueryBuilder($qb, $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->addSortToQueryBuilder($qb, $sort);

        return $this->addLimitToQueryBuilder($qb, $limit, $page);
    }
}
