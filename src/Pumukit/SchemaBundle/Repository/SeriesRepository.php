<?php

declare(strict_types=1);

namespace Pumukit\SchemaBundle\Repository;

use Doctrine\ODM\MongoDB\Query\Builder;
use Doctrine\ODM\MongoDB\Repository\DocumentRepository;
use MongoDB\BSON\ObjectId;
use MongoDB\BSON\Regex;
use Pumukit\SchemaBundle\Document\MultimediaObject;
use Pumukit\SchemaBundle\Document\Series;
use Pumukit\SchemaBundle\Document\SeriesType;
use Pumukit\SchemaBundle\Document\Tag;
use Pumukit\SchemaBundle\Document\TagInterface;
use Pumukit\SchemaBundle\Document\User;

/**
 * SeriesRepository.
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class SeriesRepository extends DocumentRepository
{
    /**
     * Find series by tag id.
     *
     * @param mixed $tag
     * @param mixed $sort
     * @param mixed $limit
     * @param mixed $page
     */
    public function findWithTag($tag, $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->createBuilderWithTag($tag, $sort);

        $qb = $this->addLimitToQueryBuilder($qb, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Create QueryBuilder to find series by tag id.
     *
     * @param Tag   $tag
     * @param array $sort
     */
    public function createBuilderWithTag($tag, $sort = []): Builder
    {
        $referencedSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findSeriesFieldWithTag($tag);

        $qb = $this->createQueryBuilder()->field('_id')->in($referencedSeries);

        return $this->addSortToQueryBuilder($qb, $sort);
    }

    /**
     * Find one series with tag.
     */
    public function findOneWithTag(TagInterface $tag)
    {
        $referencedOneSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findOneSeriesFieldWithTag($tag);

        return $this->createQueryBuilder()->field('_id')->equals($referencedOneSeries)->getQuery()->getSingleResult();
    }

    public function findWithAnyTag(array $tags, array $sort = [], int $limit = 0, int $page = 0)
    {
        $referencedSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findSeriesFieldWithAnyTag($tags);

        $qb = $this->createQueryBuilder()->field('_id')->in($referencedSeries);

        $qb = $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);

        return $qb->getQuery()->execute();
    }

    public function findWithAllTags(array $tags, array $sort = [], int $limit = 0, int $page = 0)
    {
        $referencedSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findSeriesFieldWithAllTags($tags);

        $qb = $this->createQueryBuilder()->field('_id')->in($referencedSeries);

        $qb = $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * @return array|object|Series|null
     */
    public function findOneWithAllTags(array $tags)
    {
        $referencedOneSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findOneSeriesFieldWithAllTags($tags);

        return $this->createQueryBuilder()->field('_id')->equals($referencedOneSeries)->getQuery()->getSingleResult();
    }

    public function findWithoutTag(TagInterface $tag, array $sort = [], int $limit = 0, int $page = 0)
    {
        $referencedSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findSeriesFieldWithTag($tag);

        $qb = $this->createQueryBuilder()->field('_id')->notIn($referencedSeries);

        $qb = $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Find one series without tag.
     */
    public function findOneWithoutTag(TagInterface $tag)
    {
        $referencedSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findSeriesFieldWithTag($tag);

        return $this->createQueryBuilder()->field('_id')->notIn($referencedSeries)->getQuery()->getSingleResult();
    }

    /**
     * Find series without all tags.
     *
     * @param mixed $tags
     * @param array $sort
     * @param mixed $limit
     * @param mixed $page
     *
     * @return mixed
     */
    public function findWithoutAllTags($tags, $sort = [], $limit = 0, $page = 0)
    {
        $referencedSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findSeriesFieldWithAllTags($tags);

        $qb = $this->createQueryBuilder()->field('_id')->notIn($referencedSeries);

        $qb = $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Find series by pic id.
     *
     * @param string $picId
     *
     * @return array|object|null
     */
    public function findByPicId($picId)
    {
        return $this->createQueryBuilder()->field('pics._id')->equals(new ObjectId($picId))->getQuery()->getSingleResult();
    }

    /**
     * Find series by person id.
     *
     * @param string $personId
     *
     * @return mixed
     */
    public function findSeriesByPersonId($personId)
    {
        $repoMmobj = $this->getDocumentManager()->getRepository(MultimediaObject::class);

        $referencedSeries = $repoMmobj->findSeriesFieldByPersonId($personId);

        return $this->createQueryBuilder()->field('_id')->in($referencedSeries)->getQuery()->execute();
    }

    /**
     * @param \MongoId|string $personId
     */
    public function createBuilderByPersonIdAndRoleCod($personId, string $roleCod, array $sort = [], int $limit = 0, int $page = 0): Builder
    {
        $repoMmobj = $this->getDocumentManager()->getRepository(MultimediaObject::class);
        $referencedSeries = $repoMmobj->findSeriesFieldByPersonIdAndRoleCod($personId, $roleCod);

        return $this->createQueryBuilder()->field('_id')->in($referencedSeries);
    }

    /**
     * @param \MongoId|string $personId
     *
     * @return mixed
     */
    public function findByPersonIdAndRoleCod($personId, string $roleCod, array $sort = [], int $limit = 0, int $page = 0)
    {
        $qb = $this->createBuilderByPersonIdAndRoleCod($personId, $roleCod, $sort, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Find series by person id and role cod or groups.
     *
     * @param \MongoId|string $personId
     * @param string          $roleCod
     * @param array           $groups
     *
     * @return mixed
     */
    public function findByPersonIdAndRoleCodOrGroups($personId, $roleCod, $groups)
    {
        $repoMmobj = $this->getDocumentManager()->getRepository(MultimediaObject::class);
        $referencedSeries = $repoMmobj->findSeriesFieldByPersonIdAndRoleCodOrGroups($personId, $roleCod, $groups);

        return $this->createQueryBuilder()->field('_id')->in($referencedSeries)->getQuery()->execute();
    }

    public function findByPersonIdAndRoleCodOrGroupsSortedQueryBuilder(string $personId, string $roleCod, array $groups, array $sort = [], int $limit = 0, int $page = 0)
    {
        $repoMmobj = $this->getDocumentManager()->getRepository(MultimediaObject::class);
        $referencedSeries = $repoMmobj->findSeriesFieldByPersonIdAndRoleCodOrGroups($personId, $roleCod, $groups);

        $qb = $this->createQueryBuilder()->field('_id')->in($referencedSeries);

        return $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);
    }

    public function findByPersonIdAndRoleCodOrGroupsSortedQuery(string $personId, string $roleCod, array $groups, array $sort = [], int $limit = 0, int $page = 0)
    {
        $qb = $this->findByPersonIdAndRoleCodOrGroupsSortedQueryBuilder($personId, $roleCod, $groups, $sort, $limit, $page);

        return $qb->getQuery();
    }

    public function findByPersonIdAndRoleCodOrGroupsSorted(string $personId, string $roleCod, array $groups, array $sort = [], int $limit = 0, int $page = 0)
    {
        $query = $this->findByPersonIdAndRoleCodOrGroupsSortedQuery($personId, $roleCod, $groups, $sort, $limit, $page);

        return $query->execute();
    }

    public function findBySeriesType(SeriesType $series_type)
    {
        return $this->createQueryBuilder()->field('series_type')->references($series_type)->getQuery()->execute();
    }

    public function count()
    {
        return $this->createQueryBuilder()->count()->getQuery()->execute();
    }

    public function countPublic()
    {
        return $this->getDocumentManager()
            ->getRepository(MultimediaObject::class)
            ->createStandardQueryBuilder()
            ->distinct('series')
            ->count()
            ->getQuery()
            ->execute()
        ;
    }

    public function findWithTagAndSeriesType(TagInterface $tag, SeriesType $seriesType, array $sort = [], int $limit = 0, int $page = 0)
    {
        $qb = $this->createBuilderWithTagAndSeriesType($tag, $seriesType, $sort);

        $qb = $this->addLimitToQueryBuilder($qb, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Create QueryBuilder to find series with tag and series type.
     *
     * @param Tag    $tag
     * @param object $seriesType
     * @param array  $sort
     *
     * @return mixed
     */
    public function createBuilderWithTagAndSeriesType($tag, $seriesType, $sort = [])
    {
        $referencedSeries = $this->getDocumentManager()->getRepository(MultimediaObject::class)->findSeriesFieldWithTag($tag);

        $qb = $this->createQueryBuilder()->field('_id')->in($referencedSeries)->field('series_type')->references($seriesType);

        return $this->addSortToQueryBuilder($qb, $sort);
    }

    /**
     * Find series with the same propertyName.
     *
     * @param string $propertyName
     * @param string $propertyValue
     *
     * @return array|object|null
     */
    public function findOneBySeriesProperty($propertyName, $propertyValue)
    {
        return $this->createQueryBuilder()->field('properties.'.$propertyName)->equals($propertyValue)->getQuery()->getSingleResult();
    }

    public function findByEmbeddedBroadcastTypeQueryBuilder(string $type = '', array $sort = [], int $limit = 0, int $page = 0)
    {
        $repoMmobj = $this->getDocumentManager()->getRepository(MultimediaObject::class);
        $referencedSeries = $repoMmobj->findSeriesFieldByEmbeddedBroadcastType($type);

        $qb = $this->createQueryBuilder()->field('_id')->in($referencedSeries);

        return $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);
    }

    public function findByEmbeddedBroadcastTypeQuery(string $type = '', array $sort = [], int $limit = 0, int $page = 0)
    {
        $qb = $this->findByEmbeddedBroadcastTypeQueryBuilder($type, $sort, $limit, $page);

        return $qb->getQuery();
    }

    public function findByEmbeddedBroadcastType(string $type = '', array $sort = [], int $limit = 0, int $page = 0)
    {
        $query = $this->findByEmbeddedBroadcastTypeQuery($type, $sort, $limit, $page);

        return $query->execute();
    }

    public function findByEmbeddedBroadcastTypeAndGroupsQueryBuilder(string $type = '', array $groups = [], array $sort = [], int $limit = 0, int $page = 0)
    {
        $repoMmobj = $this->getDocumentManager()->getRepository(MultimediaObject::class);
        $referencedSeries = $repoMmobj->findSeriesFieldByEmbeddedBroadcastTypeAndGroups($type, $groups);

        $qb = $this->createQueryBuilder()->field('_id')->in($referencedSeries);

        return $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);
    }

    public function findByEmbeddedBroadcastTypeAndGroupsQuery(string $type = '', array $groups = [], array $sort = [], int $limit = 0, int $page = 0)
    {
        $qb = $this->findByEmbeddedBroadcastTypeAndGroupsQueryBuilder($type, $groups, $sort, $limit, $page);

        return $qb->getQuery();
    }

    public function findByEmbeddedBroadcastTypeAndGroups(string $type = '', array $groups = [], array $sort = [], int $limit = 0, int $page = 0)
    {
        $query = $this->findByEmbeddedBroadcastTypeAndGroupsQuery($type, $groups, $sort, $limit, $page);

        return $query->execute();
    }

    public function findByTitleWithLocaleQueryBuilder(string $title = '', string $locale = 'en', array $sort = [], int $limit = 0, int $page = 0)
    {
        $qb = $this->createQueryBuilder()->field('title.'.$locale)->equals(new Regex($title, 'i'));

        return $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);
    }

    public function findByTitleWithLocaleQuery(string $title = '', string $locale = 'en', array $sort = [], int $limit = 0, int $page = 0): \Doctrine\ODM\MongoDB\Query\Query
    {
        $qb = $this->findByTitleWithLocaleQueryBuilder($title, $locale, $sort, $limit, $page);

        return $qb->getQuery();
    }

    public function findByTitleWithLocale(string $title = '', string $locale = 'en', array $sort = [], int $limit = 0, int $page = 0)
    {
        $query = $this->findByTitleWithLocaleQuery($title, $locale, $sort, $limit, $page);

        return $query->execute();
    }

    /**
     * @param User $user
     * @param bool $onlyAdminSeries
     *
     * @throws \Doctrine\ODM\MongoDB\MongoDBException
     *
     * @return array
     */
    public function findUserSeries($user, $onlyAdminSeries = false)
    {
        $dm = $this->getDocumentManager();

        // Find user series (properties.owners)
        $seriesCollection = $dm->getDocumentCollection(Series::class);

        if (($permissionProfile = $user->getPermissionProfile()) && $permissionProfile->isGlobal() && !$onlyAdminSeries) {
            $group = ['_id' => ['id' => '$_id', 'title' => '$title']];
            $command = [['$group' => $group]];

            return iterator_to_array($seriesCollection->aggregate($command, ['cursor' => []]));
        }

        $match = [];
        $match['properties.owners'] = ['$in' => [$user->getId()]];
        $group = ['_id' => ['id' => '$_id', 'title' => '$title']];

        $command = [['$match' => $match], ['$group' => $group]];
        $aSeries = iterator_to_array($seriesCollection->aggregate($command, ['cursor' => []]));

        // Find mmo user groups
        $mmoCollection = $dm->getDocumentCollection(MultimediaObject::class);

        $groups = [];
        foreach ($user->getGroups() as $group) {
            $groups[] = new ObjectId($group->getId());
        }

        $match = [];
        $unwind = ['$unwind' => '$groups'];
        $match['groups'] = ['$in' => $groups];
        $group = ['_id' => ['id' => '$series', 'title' => '$seriesTitle']];

        $command = [$unwind, ['$match' => $match], ['$group' => $group]];
        $aMMO = $mmoCollection->aggregate($command, ['cursor' => []]);

        $aSeries = array_merge($aSeries, $aMMO);
        usort($aSeries, function ($a, $b) {
            return ($a['_id']['title'] <= $b['_id']['title']) ? -1 : 1;
        });

        return $aSeries;
    }

    /**
     * Count number of multimedia objects by series.
     *
     * @deprecated Use MultimediaObjectRepository::countMmobjsBySeries
     *
     * @param array $seriesList A key/value hash where the key is the series id (string) and the value is the count
     *
     * @return mixed
     */
    public function countMmobjsBySeries($seriesList = [])
    {
        return $this->getDocumentManager()
            ->getRepository(MultimediaObject::class)
            ->countMmobjsBySeries($seriesList)
        ;
    }

    /**
     * @return mixed
     */
    public function getMultimediaObjects(Series $series)
    {
        return $this->getDocumentManager()
            ->getRepository(MultimediaObject::class)
            ->findWithoutPrototype($series)
        ;
    }

    /**
     * @return mixed
     */
    public function countMultimediaObjects(Series $series)
    {
        return $this->getDocumentManager()
            ->getRepository(MultimediaObject::class)
            ->countWithoutPrototype($series)
        ;
    }

    /**
     * Add limit (and page) to Query Builder.
     *
     * @param Builder $qb
     * @param int     $limit
     * @param int     $page
     *
     * @return mixed
     */
    private function addLimitToQueryBuilder($qb, $limit = 0, $page = 0)
    {
        if ($limit > 0) {
            $qb->limit($limit)->skip($limit * $page);
        }

        return $qb;
    }

    /**
     * Add sort to Query Builder.
     *
     * @param Builder $qb
     * @param array   $sort
     *
     * @return mixed
     */
    private function addSortToQueryBuilder($qb, $sort = [])
    {
        if (0 !== count($sort)) {
            $qb->sort($sort);
        }

        return $qb;
    }

    /**
     * Add sort and limit (and page) to Query Builder.
     *
     * @param Builder $qb
     * @param array   $sort
     * @param int     $limit
     * @param int     $page
     *
     * @return mixed
     */
    private function addSortAndLimitToQueryBuilder($qb, $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->addSortToQueryBuilder($qb, $sort);

        return $this->addLimitToQueryBuilder($qb, $limit, $page);
    }
}
