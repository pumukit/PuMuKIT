<?php

namespace Pumukit\SchemaBundle\Repository;

use Doctrine\ODM\MongoDB\Query\Builder;
use Doctrine\ODM\MongoDB\Repository\DocumentRepository;
use MongoDB\BSON\ObjectId;
use MongoDB\BSON\Regex;
use MongoDB\BSON\UTCDateTime;
use Pumukit\SchemaBundle\Document\Broadcast;
use Pumukit\SchemaBundle\Document\EmbeddedBroadcast;
use Pumukit\SchemaBundle\Document\Group;
use Pumukit\SchemaBundle\Document\MultimediaObject;
use Pumukit\SchemaBundle\Document\Series;
use Pumukit\SchemaBundle\Document\Tag;
use Pumukit\SchemaBundle\Utils\Mongo\TextIndexUtils;

/**
 * MultimediaObjectRepository.
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class MultimediaObjectRepository extends DocumentRepository
{
    /**
     * Find all multimedia objects in a series with given status.
     *
     * @param int $limit
     * @param int $page
     *
     * @return mixed
     */
    public function findWithStatus(Series $series, array $status, $limit = 0, $page = 0)
    {
        $qb = $this->createQueryBuilder()->field('series')->references($series)->field('status')->in($status)->sort('rank', 1);

        $qb = $this->addLimitToQueryBuilder($qb, $limit, $page);

        return $qb->getQuery()->execute()->toArray();
    }

    /**
     * Find multimedia object prototype.
     *
     * @return array|object|null
     */
    public function findPrototype(Series $series)
    {
        return $this->createQueryBuilder()
            ->field('series')->references($series)
            ->field('status')->equals(MultimediaObject::STATUS_PROTOTYPE)
            ->getQuery()
            ->getSingleResult()
        ;
    }

    /**
     * Find multimedia objects in a series
     * without the template (prototype).
     *
     * @return mixed
     */
    public function findWithoutPrototype(Series $series)
    {
        return $this->createQueryBuilder()
            ->field('series')->references($series)
            ->field('status')->notEqual(MultimediaObject::STATUS_PROTOTYPE)
            ->sort('rank', 1)
            ->getQuery()
            ->execute()
            ->toArray()
        ;
    }

    /**
     * Count multimedia objects in a series
     * without the template (prototype).
     *
     * @return int
     */
    public function countWithoutPrototype(Series $series)
    {
        return $this->createQueryBuilder()
            ->field('series')->references($series)
            ->field('status')->notEqual(MultimediaObject::STATUS_PROTOTYPE)
            ->sort('rank', 1)
            ->getQuery()
            ->count()
        ;
    }

    /**
     * Find multimedia objects by pic id.
     *
     * @param string $picId
     *
     * @return array|object|null
     */
    public function findByPicId($picId)
    {
        return $this->createQueryBuilder()
            ->field('pics._id')->equals(new ObjectId($picId))->getQuery()
            ->getSingleResult()
        ;
    }

    public function qbByPersonId($personId)
    {
        return $this->createStandardQueryBuilder()
            ->field('people.people._id')
            ->equals(new ObjectId($personId))
            ;
    }

    public function findByPersonId($personId)
    {
        return $this->qbByPersonId($personId)
            ->getQuery()
            ->execute()
            ;
    }

    public function countByPersonId($personId)
    {
        return $this->qbByPersonId($personId)
            ->count()
            ->getQuery()
            ->execute()
        ;
    }

    /**
     * Find multimedia objects by role code.
     *
     * @param string $roleCode
     *
     * @return mixed
     */
    public function findByRoleCod($roleCode)
    {
        return $this->createStandardQueryBuilder()
            ->field('people.cod')->equals($roleCode)
            ->getQuery()
            ->execute()
        ;
    }

    /**
     * Find multimedia objects by role id.
     *
     * @param string $roleId
     *
     * @return mixed
     */
    public function findByRoleId($roleId)
    {
        return $this->createStandardQueryBuilder()
            ->field('people._id')->equals(new ObjectId($roleId))
            ->getQuery()
            ->execute()
        ;
    }

    /**
     * Find multimedia objects by track id.
     *
     * @param string $trackId
     *
     * @return array|object|null
     */
    public function findOneByTrackId($trackId)
    {
        return $this->createStandardQueryBuilder()
            ->field('tracks._id')->equals(new ObjectId($trackId))
            ->getQuery()
            ->getSingleResult()
        ;
    }

    /**
     * Create query builder of
     * find multimedia objects by person id
     * with given role.
     *
     * @param string $personId
     * @param string $roleCod
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return Builder
     */
    public function createBuilderByPersonIdWithRoleCod($personId, $roleCod, $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->createQueryBuilder();
        $qb->field('people')->elemMatch($qb->expr()->field('people._id')->equals(new ObjectId($personId))->field('cod')->equals($roleCod));

        $qb = $this->addSortToQueryBuilder($qb, $sort);

        return $this->addLimitToQueryBuilder($qb, $limit, $page);
    }

    /**
     * @throws \Doctrine\ODM\MongoDB\MongoDBException
     *
     * @return mixed
     */
    public function findByPersonIdWithRoleCod(string $personId, string $roleCod, array $sort = [], int $limit = 0, int $page = 0)
    {
        $qb = $this->createBuilderByPersonIdWithRoleCod($personId, $roleCod, $sort, $limit, $page);

        return $qb->getQuery()->execute();
    }

    public function countByPersonIdWithRoleCod(string $personId, string $roleCod, array $sort = [], int $limit = 0, int $page = 0): int
    {
        $qb = $this->createBuilderByPersonIdWithRoleCod($personId, $roleCod, $sort, $limit, $page);
        return $qb->count()->getQuery()->execute();
    }

    /**
     * @return mixed
     */
    public function findBySeriesAndPersonIdWithRoleCod(Series $series, string $personId, string $roleCod)
    {
        $qb = $this->createStandardQueryBuilder()->field('series')->references($series);
        $qb->field('people')->elemMatch($qb->expr()->field('people._id')->equals(new ObjectId($personId))->field('cod')->equals($roleCod));

        return $qb->getQuery()->execute();
    }

    /**
     * Find people in multimedia objects with given role.
     *
     * @param string $roleCode
     *
     * @throws \Doctrine\ODM\MongoDB\MongoDBException
     *
     * @return array
     */
    public function findPeopleWithRoleCode($roleCode)
    {
        $dm = $this->getDocumentManager();
        $collection = $dm->getDocumentCollection(MultimediaObject::class);

        $pipeline = [
            ['$match' => ['people.cod' => (string) ($roleCode)]],
            [
                '$project' => [
                    '_id' => 0,
                    'people.cod' => 1,
                    'people.people._id' => 1,
                ],
            ],
            ['$unwind' => '$people'],
        ];

        $aggregation = $collection->aggregate($pipeline, ['cursor' => []]);

        $people = [];
        foreach ($aggregation as $element) {
            if (null === $element['people']) {
                continue;
            }
            if ((null === $element['people']['cod']) || (null === $element['people']['people'])) {
                continue;
            }
            if (0 !== strpos($element['people']['cod'], $roleCode)) {
                continue;
            }
            foreach ($element['people']['people'] as $person) {
                if (in_array($person['_id'], $people, false)) {
                    continue;
                }
                $people[] = $person['_id'];
            }
        }

        return $people;
    }

    public function findPeopleWithRoleCodeAndId(string $roleCode, string $email): array
    {
        $dm = $this->getDocumentManager();
        $collection = $dm->getDocumentCollection(MultimediaObject::class);

        $pipeline = [
            [
                '$match' => [
                    'people.cod' => (string) ($roleCode),
                    'people.people.email' => (string) ($email),
                ],
            ],
            [
                '$project' => [
                    '_id' => 0,
                    'people.cod' => 1,
                    'people.people.email' => 1,
                    'people.people._id' => 1,
                ],
            ],
            ['$unwind' => '$people'],
        ];

        $aggregation = $collection->aggregate($pipeline, ['cursor' => []]);

        $people = [];
        foreach ($aggregation as $element) {
            if (null === $element['people']) {
                continue;
            }
            if ((null === $element['people']['cod']) || (null === $element['people']['people'])) {
                continue;
            }
            if (0 !== strpos($element['people']['cod'], $roleCode)) {
                continue;
            }

            foreach ($element['people']['people'] as $person) {
                if ($person['email'] !== $email) {
                    continue;
                }
                if (in_array($person['_id'], $people, false)) {
                    continue;
                }
                $people[] = $person['_id'];
            }
        }

        return $people;
    }

    /**
     * Find series by person id.
     *
     * @param string $personId
     *
     * @return mixed
     */
    public function findSeriesFieldByPersonId($personId)
    {
        return $this->createQueryBuilder()
            ->field('people.people._id')->equals(new ObjectId($personId))
            ->distinct('series')
            ->getQuery()
            ->execute()
        ;
    }

    /**
     * Search series using text index.
     *
     * @param string $text
     * @param int    $limit
     * @param int    $page
     *
     * @return mixed
     */
    public function searchSeriesField($text, $limit = 0, $page = 0)
    {
        $qb = $this->createQueryBuilder()
            ->field('$text')->equals(['$search' => $text])
            ->distinct('series')
        ;

        $qb = $this->addLimitToQueryBuilder($qb, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Search series using text index or the _id.
     *
     * @param string $text
     * @param int    $limit
     * @param int    $page
     * @param string $locale
     *
     * @return mixed
     */
    public function getIdsWithSeriesTextOrId($text, $limit = 0, $page = 0, $locale = 'en')
    {
        $qb = $this->createStandardQueryBuilder();

        $text = trim($text);
        if ((false !== strpos($text, '*')) && (false === strpos($text, ' '))) {
            $text = str_replace('*', '.*', $text);
            $mRegex = new Regex("{$text}", 'i');
            $qb->addOr($qb->expr()->field('title'.$locale)->equals($mRegex));
            $qb->addOr($qb->expr()->field('people.people.name')->equals($mRegex));
        } else {
            $qb->addOr($qb->expr()->field('$text')->equals([
                '$search' => TextIndexUtils::cleanTextIndex($text),
                '$language' => TextIndexUtils::getCloseLanguage($locale),
            ]));
            $qb->addOr($qb->expr()->field('_id')->equals($text));
        }

        $qb->distinct('series');

        $qb = $this->addLimitToQueryBuilder($qb, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Find series by person id and role code.
     *
     * @param string $personId
     * @param string $roleCod
     *
     * @return mixed
     */
    public function findSeriesFieldByPersonIdAndRoleCod($personId, $roleCod)
    {
        $qb = $this->createQueryBuilder();
        $qb->field('people')
            ->elemMatch(
                $qb->expr()
                    ->field('people._id')->equals(new ObjectId($personId))
                    ->field('cod')->equals($roleCod)
            )
        ;

        return $qb->distinct('series')->getQuery()->execute();
    }

    /**
     * Find by person id and role code or groups query builder.
     *
     * @param string $personId
     * @param string $roleCod
     * @param array  $groups
     *
     * @return \Doctrine\ODM\MongoDB\Query\Builder
     */
    public function findByPersonIdAndRoleCodOrGroupsQueryBuilder($personId, $roleCod, $groups)
    {
        $groupsIds = $this->getGroupsIdsArray($groups);

        $qb = $this->createQueryBuilder();
        $qb->addOr($qb->expr()->field('groups')->in($groupsIds));
        $qb->addOr($qb->expr()->field('people')->elemMatch($qb->expr()->field('people._id')->equals(new ObjectId($personId))->field('cod')->equals($roleCod)));

        return $qb;
    }

    /**
     * Find by person id
     * and role code or groups
     * query.
     *
     * @param string $personId
     * @param string $roleCod
     * @param array  $groups
     *
     * @return \Doctrine\ODM\MongoDB\Query\Query
     */
    public function findByPersonIdAndRoleCodOrGroupsQuery($personId, $roleCod, $groups)
    {
        $qb = $this->findByPersonIdAndRoleCodOrGroupsQueryBuilder($personId, $roleCod, $groups);

        return $qb->getQuery();
    }

    /**
     * Find by person id and role code or groups.
     *
     * @param string $personId
     * @param string $roleCod
     * @param array  $groups
     *
     * @throws \Doctrine\ODM\MongoDB\MongoDBException
     *
     * @return mixed
     */
    public function findByPersonIdAndRoleCodOrGroups($personId, $roleCod, $groups)
    {
        $query = $this->findByPersonIdAndRoleCodOrGroupsQuery($personId, $roleCod, $groups);

        return $query->execute();
    }

    /**
     * Find series by person id and role code or groups.
     *
     * @param string $personId
     * @param string $roleCod
     * @param array  $groups
     *
     * @return mixed
     */
    public function findSeriesFieldByPersonIdAndRoleCodOrGroups($personId, $roleCod, $groups)
    {
        $qb = $this->findByPersonIdAndRoleCodOrGroupsQueryBuilder($personId, $roleCod, $groups);

        return $qb->distinct('series')->getQuery()->execute();
    }

    /**
     * Find multimedia objects by tag id.
     *
     * @param array $sort
     * @param int   $limit
     * @param int   $page
     *
     * @return mixed
     */
    public function findWithTag(Tag $tag, $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->createBuilderWithTag($tag, $sort);

        $qb = $this->addLimitToQueryBuilder($qb, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Find multimedia objects by tag id without tag children.
     *
     * @param array $sort
     * @param int   $limit
     * @param int   $page
     *
     * @return mixed
     */
    public function findWithGeneralTag(Tag $tag, $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->createBuilderWithGeneralTag($tag, $sort);

        $qb = $this->addLimitToQueryBuilder($qb, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Create QueryBuilder to find multimedia objects by tag id.
     *
     * @param array $sort
     *
     * @return \Doctrine\MongoDB\Query\Builder|mixed
     */
    public function createBuilderWithTag(Tag $tag, $sort = [])
    {
        $qb = $this->createStandardQueryBuilder()->field('tags.cod')->equals($tag->getCod());

        return $this->addSortToQueryBuilder($qb, $sort);
    }

    /**
     * Create QueryBuilder to find multimedia objects by series.
     *
     * @param array $sort
     *
     * @return mixed
     */
    public function createBuilderWithSeries(Series $series, $sort = [])
    {
        $qb = $this->createStandardQueryBuilder()->field('series')->references($series);

        return $this->addSortToQueryBuilder($qb, $sort);
    }

    /**
     * Create QueryBuilder to find multimedia objects by series and status.
     *
     * @param array $status
     * @param array $sort
     *
     * @return \Doctrine\MongoDB\Query\Builder|mixed
     */
    public function createBuilderWithSeriesAndStatus(Series $series, $status = [], $sort = [])
    {
        $qb = $this->createQueryBuilder()->field('series')->references($series)->field('status')->in($status);

        return $this->addSortToQueryBuilder($qb, $sort);
    }

    /**
     * Create QueryBuilder to find multimedia objects with Tag and without any Tag children.
     *
     * @param array $sort
     *
     * @return \Doctrine\MongoDB\Query\Builder|mixed
     */
    public function createBuilderWithGeneralTag(Tag $tag, $sort = [])
    {
        $qb = $this->createStandardQueryBuilder()->field('tags.cod')->equals($tag->getCod())->field('tags.path')->notIn([new Regex(preg_quote($tag->getPath()).'.*\|/')]);

        return $this->addSortToQueryBuilder($qb, $sort);
    }

    /**
     * Find one multimedia object by tag id.
     *
     * @return array|object|null
     */
    public function findOneWithTag(Tag $tag)
    {
        return $this->createStandardQueryBuilder()->field('tags._id')->equals(new ObjectId($tag->getId()))->getQuery()->getSingleResult();
    }

    /**
     * Find multimedia objects with any tag.
     *
     * @param array $tags
     * @param array $sort
     * @param int   $limit
     * @param int   $page
     *
     * @return mixed
     */
    public function findWithAnyTag($tags, $sort = [], $limit = 0, $page = 0)
    {
        $mongoIds = $this->getMongoIds($tags);
        $qb = $this->createStandardQueryBuilder()->field('tags._id')->in($mongoIds);

        $qb = $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Find multimedia objects with all tags.
     *
     * @param array $tags
     * @param array $sort
     * @param int   $limit
     * @param int   $page
     *
     * @return mixed
     */
    public function findWithAllTags($tags, $sort = [], $limit = 0, $page = 0)
    {
        $mongoIds = $this->getMongoIds($tags);
        $qb = $this->createStandardQueryBuilder()->field('tags._id')->all($mongoIds);

        $qb = $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Find one multimedia object with all tags.
     *
     * @param array $tags
     *
     * @return array|object|null
     */
    public function findOneWithAllTags($tags)
    {
        $mongoIds = $this->getMongoIds($tags);
        $qb = $this->createStandardQueryBuilder()->field('tags._id')->all($mongoIds);

        return $qb->getQuery()->getSingleResult();
    }

    public function qbWithoutTag(Tag $tag, array $sort = [], int $limit = 0, int $page = 0)
    {
        $qb = $this->createStandardQueryBuilder()->field('tags._id')->notEqual(new ObjectId($tag->getId()));

        return $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);
    }

    public function findWithoutTag(Tag $tag, array $sort = [], int $limit = 0, int $page = 0)
    {
        return $this->qbWithoutTag($tag, $sort, $limit, $page)->getQuery()->execute();
    }

    public function countWithoutTag(Tag $tag, array $sort = [], int $limit = 0, int $page = 0)
    {
        return $this->qbWithoutTag($tag, $sort, $limit, $page)->count()->getQuery()->execute();
    }

    /**
     * Find one multimedia object without tag id.
     *
     * @return array|object|null
     */
    public function findOneWithoutTag(Tag $tag)
    {
        return $this->createStandardQueryBuilder()->field('tags._id')->notEqual(new ObjectId($tag->getId()))->getQuery()->getSingleResult();
    }

    /**
     * Find multimedia objects without all tags.
     *
     * @param array $tags
     * @param array $sort
     * @param int   $limit
     * @param int   $page
     *
     * @return mixed
     */
    public function findWithoutAllTags($tags, $sort = [], $limit = 0, $page = 0)
    {
        $mongoIds = $this->getMongoIds($tags);
        $qb = $this->createStandardQueryBuilder()->field('tags._id')->notIn($mongoIds);

        $qb = $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Find series with tag.
     *
     * @return mixed
     */
    public function findSeriesFieldWithTag(Tag $tag)
    {
        return $this->createStandardQueryBuilder()
            ->field('tags._id')->equals(new ObjectId($tag->getId()))
            ->distinct('series')
            ->getQuery()
            ->execute()
        ;
    }

    public function findOneSeriesFieldWithTag(Tag $tag): ?ObjectId
    {
        $series = $this->createStandardQueryBuilder()
            ->field('tags._id')
            ->equals(new ObjectId($tag->getId()))
            ->distinct('series')
            ->getQuery()
            ->execute();
        return $series[0] ?? null;
    }

    /**
     * Find series with any tag.
     *
     * @param array $tags
     *
     * @return mixed
     */
    public function findSeriesFieldWithAnyTag($tags)
    {
        $mongoIds = $this->getMongoIds($tags);

        return $this->createStandardQueryBuilder()->field('tags._id')->in($mongoIds)->distinct('series')->getQuery()->execute();
    }

    /**
     * Find series with all tags.
     *
     * @param array $tags
     *
     * @return mixed
     */
    public function findSeriesFieldWithAllTags($tags)
    {
        $mongoIds = $this->getMongoIds($tags);

        return $this->createStandardQueryBuilder()->field('tags._id')->all($mongoIds)->distinct('series')->getQuery()->execute();
    }

    public function findOneSeriesFieldWithAllTags(array $tags): ?ObjectId
    {
        $mongoIds = $this->getMongoIds($tags);
        $series = $this->createStandardQueryBuilder()
            ->field('tags._id')
            ->all($mongoIds)
            ->distinct('series')
            ->getQuery()
            ->execute();
        return $series[0] ?? null;
    }

    /**
     * Find distinct url pics in series.
     *
     * @return mixed
     */
    public function findDistinctUrlPicsInSeries(Series $series)
    {
        return $this->createStandardQueryBuilder()->field('series')->references($series)->distinct('pics.url')->getQuery()->execute();
    }

    /**
     * Find distinct url pics.
     *
     * @return mixed
     */
    public function findDistinctUrlPics()
    {
        return $this->createStandardQueryBuilder()->distinct('pics.url')->sort('public_date', 1)->getQuery()->execute();
    }

    /**
     * Find by series.
     *
     * @throws \Doctrine\ODM\MongoDB\MongoDBException
     *
     * @return mixed
     */
    public function findBySeries(Series $series)
    {
        return $this->createQueryBuilder()->field('series')->references($series)->getQuery()->execute();
    }

    /**
     * Find by series.
     *
     * @param int $limit
     * @param int $page
     *
     * @return mixed
     */
    public function findStandardBySeries(Series $series, $limit = 0, $page = 1)
    {
        $qb = $this->createStandardQueryBuilder()->field('series')->references($series);

        $qb = $this->addLimitToQueryBuilder($qb, $limit, $page);

        return $qb->sort('rank', 1)->getQuery()->execute();
    }

    /**
     * Find by series, tag code and status. Not needed (Using findBySeries and filter).
     *
     * @param string $tagCod
     * @param array  $status
     *
     * @return mixed
     */
    public function findBySeriesByTagCodAndStatus(Series $series, $tagCod, $status = [])
    {
        $qb = $this->createStandardQueryBuilder()->field('series')->references($series)->field('tags.cod')->equals($tagCod);

        if (0 !== count($status)) {
            $qb->field('status')->in($status);
        }

        $qb->sort('rank', 'asc');

        return $qb->getQuery()->execute();
    }

    /**
     * Find by embedded broadcast.
     *
     * @return mixed
     */
    public function findByEmbeddedBroadcast(EmbeddedBroadcast $embeddedBroadcast)
    {
        return $this->createQueryBuilder()->field('embeddedBroadcast._id')->equals(new ObjectId($embeddedBroadcast->getId()))->getQuery()->execute();
    }

    /**
     * Find by embedded broadcast type query builder.
     *
     * @param string $type
     *
     * @return \Doctrine\MongoDB\Query\Builder
     */
    public function findByEmbeddedBroadcastTypeQueryBuilder($type)
    {
        return $this->createQueryBuilder()->field('embeddedBroadcast.type')->equals($type);
    }

    /**
     * Find by embedded broadcast type query.
     *
     * @param string $type
     *
     * @return \Doctrine\MongoDB\Query\Query
     */
    public function findByEmbeddedBroadcastTypeQuery($type)
    {
        return $this->findByEmbeddedBroadcastTypeQueryBuilder($type)->getQuery();
    }

    /**
     * Find by embedded broadcast type.
     *
     * @param string $type
     *
     * @return mixed
     */
    public function findByEmbeddedBroadcastType($type)
    {
        return $this->findByEmbeddedBroadcastTypeQuery($type)->execute();
    }

    /**
     * Find ordered by fieldName: asc/desc.
     *
     * @param array $sort
     *
     * @return mixed
     */
    public function getQueryBuilderOrderedBy(Series $series, $sort = [])
    {
        $qb = $this->createStandardQueryBuilder()->field('series')->references($series);

        return $this->addSortToQueryBuilder($qb, $sort);
    }

    /**
     * Find ordered by fieldName: asc/desc.
     *
     * @param array $sort
     *
     * @return mixed
     */
    public function findOrderedBy(Series $series, $sort = [])
    {
        $qb = $this->getQueryBuilderOrderedBy($series, $sort);

        return $qb->getQuery()->execute()->toArray();
    }

    public function createStandardQueryBuilder(): Builder
    {
        return $this->createQueryBuilder()
            ->field('status')->notEqual(MultimediaObject::STATUS_PROTOTYPE)
            ->field('type')->notEqual(MultimediaObject::TYPE_LIVE);
    }

    public function createAggregationStandardQueryBuilder(): \Doctrine\ODM\MongoDB\Aggregation\Stage\Match
    {
        return $this->createAggregationBuilder()
            ->match()
            ->field('status')->notEqual(MultimediaObject::STATUS_PROTOTYPE)
            ->field('type')->notEqual(MultimediaObject::TYPE_LIVE);
    }

    /**
     * Finds standard MultimediaObjects (not prototype) by a set of criteria.
     *
     * @param array    $criteria Query criteria
     * @param array    $sort     Sort array for Cursor::sort()
     * @param int|null $limit    Limit for Cursor::limit()
     * @param int|null $skip     Skip for Cursor::skip()
     *
     * @return array
     */
    public function findStandardBy(array $criteria, array $sort = null, $limit = null, $skip = null)
    {
        $criteria['status'] = MultimediaObject::STATUS_PUBLISHED;

        return $this->getDocumentPersister()->loadAll($criteria, $sort, $limit, $skip)->toArray(false);
    }

    /**
     * Finds a single standard MultimediaObject (not prototype) by a set of criteria.
     *
     * @throws \Doctrine\ODM\MongoDB\LockException
     *
     * @return object|null
     */
    public function findStandardOneBy(array $criteria)
    {
        $criteria['status'] = MultimediaObject::STATUS_PUBLISHED;

        return $this->getDocumentPersister()->load($criteria);
    }

    /**
     * Find similar multimedia objects to a given one with same tags, from different series,
     * broadcast public, status normal, maximum 20 and random.
     *
     * @param string $tagBase
     *
     * @return mixed
     */
    public function findRelatedMultimediaObjects(MultimediaObject $multimediaObject, $tagBase = 'UNESCO')
    {
        $qb = $this->createQueryBuilder()->field('_id')->notEqual($multimediaObject->getId())->field('series')->notEqual($multimediaObject->getSeries()->getId())->field('status')->equals(MultimediaObject::STATUS_PUBLISHED)->field('embeddedBroadcast.type')->equals(EmbeddedBroadcast::TYPE_PUBLIC);

        // Includes PUCHWEBTV code
        $tagRepo = $this->dm->getRepository(Tag::class);
        $unescoTag = $tagRepo->findOneByCod($tagBase);
        $codes = [];
        foreach ($multimediaObject->getTags() as $tag) {
            if ($unescoTag) {
                if ($tag->isDescendantOf($unescoTag)) {
                    $codes[] = $tag->getCod();
                }
            }
        }
        $qb->field('tags.cod')->in($codes);

        // Limit 20 and random order
        $qb->limit(20)->sort('rank', mt_rand(0, 1) ? 1 : -1);

        return $qb->getQuery()->execute();
    }

    public function count(): int
    {
        return $this->createStandardQueryBuilder()->count()->getQuery()->execute();
    }

    public function countDuration(): int
    {
        $aggregation = $this->createAggregationStandardQueryBuilder()
            ->group()
            ->field('id')->expression('id')
            ->field('total_duration')->sum('$duration')
            ->execute()
        ;

        return $aggregation->current()['total_duration'];
    }

    public function countInSeries($series): int
    {
        return $this->createStandardQueryBuilder()->field('series')->references($series)->count()->getQuery()->execute();
    }

    /**
     * Find by tag query builder.
     *
     * @param Tag $tag
     *
     * @return \Doctrine\MongoDB\Query\Builder
     */
    public function findByTagCodQueryBuilder($tag)
    {
        return $this->createStandardQueryBuilder()->field('tags.cod')->equals($tag->getCod());
    }

    /**
     * Find by tag query.
     *
     * @param Tag   $tag
     * @param array $sort
     *
     * @return mixed
     */
    public function findByTagCodQuery($tag, $sort = [])
    {
        $qb = $this->findByTagCodQueryBuilder($tag);
        $qb = $this->addSortToQueryBuilder($qb, $sort);

        return $qb->getQuery();
    }

    /**
     * Find by tag code.
     *
     * @param Tag   $tag
     * @param array $sort
     *
     * @return mixed
     */
    public function findByTagCod($tag, $sort = [])
    {
        return $this->findByTagCodQuery($tag, $sort)->execute();
    }

    /**
     * Find all by tag query builder.
     *
     * @param Tag $tag
     *
     * @return \Doctrine\MongoDB\Query\Builder
     */
    public function findAllByTagQueryBuilder($tag)
    {
        return $this->createQueryBuilder()->field('tags._id')->equals(new ObjectId($tag->getId()));
    }

    /**
     * Find all by tag query.
     *
     * @param Tag   $tag
     * @param array $sort
     *
     * @return mixed
     */
    public function findAllByTagQuery($tag, $sort = [])
    {
        $qb = $this->findAllByTagQueryBuilder($tag);
        $qb = $this->addSortToQueryBuilder($qb, $sort);

        return $qb->getQuery();
    }

    /**
     * Find all by tag.
     *
     * @param Tag   $tag
     * @param array $sort
     *
     * @return mixed
     */
    public function findAllByTag($tag, $sort = [])
    {
        return $this->findAllByTagQuery($tag, $sort)->execute();
    }

    /**
     * Returns all mmobjs (except prototypes) using a QueryBuilder.
     * The method $this->findAll() would return an array with ALL multimedia objects.
     * This is quite unconvenient when having tens of thousands of multimedia objects.
     * This function returns a Cursor instead, by using a QueryBuilder and executing it.
     * It also filters the 'Prototype' Multimedia Objects, which are generally not wanted, by default.
     *
     * @param bool $filter_prototype
     *
     * @throws \Doctrine\ODM\MongoDB\MongoDBException
     *
     * @return mixed
     */
    public function findAllAsIterable($filter_prototype = true)
    {
        if ($filter_prototype) {
            $qb = $this->createStandardQueryBuilder();
        } else {
            $qb = $this->createQueryBuilder();
        }

        return $qb->getQuery()->execute();
    }

    /**
     * Create QueryBuilder to find multimedia objects with group.
     *
     * @param array $sort
     *
     * @return \Doctrine\MongoDB\Query\Builder|mixed
     */
    public function createBuilderWithGroup(Group $group, $sort = [])
    {
        $qb = $this->createQueryBuilder()->field('groups')->in([new ObjectId($group->getId())]);

        return $this->addSortToQueryBuilder($qb, $sort);
    }

    /**
     * Find multimedia objects with group.
     *
     * @param array $sort
     * @param int   $limit
     * @param int   $page
     *
     * @return mixed
     */
    public function findWithGroup(Group $group, $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->createBuilderWithGroup($group, $sort);

        $qb = $this->addLimitToQueryBuilder($qb, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Count multimedia objects with group.
     *
     * @param array $sort
     * @param int   $limit
     * @param int   $page
     *
     * @return mixed
     */
    public function countWithGroup(Group $group, $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->createBuilderWithGroup($group, $sort);

        $qb = $this->addLimitToQueryBuilder($qb, $limit, $page);

        return $qb->count()->getQuery()->execute();
    }

    /**
     * Create QueryBuilder to find multimedia objects with group.
     *
     * @param array $sort
     *
     * @return \Doctrine\MongoDB\Query\Builder|mixed
     */
    public function createBuilderWithGroupInEmbeddedBroadcast(Group $group, $sort = [])
    {
        $qb = $this->createQueryBuilder()->field('embeddedBroadcast.groups')->in([new ObjectId($group->getId())]);

        return $this->addSortToQueryBuilder($qb, $sort);
    }

    /**
     * Find multimedia objects with group.
     *
     * @param array $sort
     * @param int   $limit
     * @param int   $page
     *
     * @return mixed
     */
    public function findWithGroupInEmbeddedBroadcast(Group $group, $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->createBuilderWithGroupInEmbeddedBroadcast($group, $sort);

        $qb = $this->addLimitToQueryBuilder($qb, $limit, $page);

        return $qb->getQuery()->execute();
    }

    /**
     * Count multimedia objects with group in embedded broadcast.
     *
     * @param array $sort
     * @param int   $limit
     * @param int   $page
     *
     * @return mixed
     */
    public function countWithGroupInEmbeddedBroadcast(Group $group, $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->createBuilderWithGroupInEmbeddedBroadcast($group, $sort);

        $qb = $this->addLimitToQueryBuilder($qb, $limit, $page);

        return $qb->count()->getQuery()->execute();
    }

    /**
     * Count in series with embedded broadcast type.
     *
     * @param string $type
     *
     * @return mixed
     */
    public function countInSeriesWithEmbeddedBroadcastType(Series $series, $type = '')
    {
        return $this->createQueryBuilder()->field('series')->references($series)->field('embeddedBroadcast.type')->equals($type)->count()->getQuery()->execute();
    }

    /**
     * Count in series with embedded broadcast password.
     *
     * @param string $type
     * @param string $password
     *
     * @return mixed
     */
    public function countInSeriesWithEmbeddedBroadcastPassword(Series $series, $type = '', $password = '')
    {
        return $this->createQueryBuilder()->field('series')->references($series)->field('embeddedBroadcast.type')->equals($type)->field('embeddedBroadcast.password')->equals($password)->count()->getQuery()->execute();
    }

    /**
     * Count in series with embedded broadcast groups.
     *
     * @param string $type
     * @param array  $groups
     *
     * @return mixed
     */
    public function countInSeriesWithEmbeddedBroadcastGroups(Series $series, $type = '', $groups = [])
    {
        $groupsIds = $this->getGroupsIdsArray($groups);

        return $this->createQueryBuilder()->field('series')->references($series)->field('embeddedBroadcast.type')->equals($type)->field('embeddedBroadcast.groups')->all($groupsIds)->field('embeddedBroadcast.groups')->size(count($groupsIds))->count()->getQuery()->execute();
    }

    /**
     * Count number of all multimedia objects in a Series
     * (including prototype).
     *
     * @return mixed
     */
    public function countInSeriesWithPrototype(Series $series)
    {
        return $this->createQueryBuilder()->field('series')->references($series)->count()->getQuery()->execute();
    }

    /**
     * Find Series field by EmbeddedBroadcast type Query Builder.
     *
     * @param string $type
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return \Doctrine\MongoDB\Query\Builder|mixed
     */
    public function findSeriesFieldByEmbeddedBroadcastTypeQueryBuilder($type = '', $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->findByEmbeddedBroadcastTypeQueryBuilder($type)->distinct('series');

        return $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);
    }

    /**
     * Find Series field by EmbeddedBroadcast type Query.
     *
     * @param string $type
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return \Doctrine\MongoDB\Query\Query
     */
    public function findSeriesFieldByEmbeddedBroadcastTypeQuery($type = '', $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->findSeriesFieldByEmbeddedBroadcastTypeQueryBuilder($type, $sort, $limit, $page);

        return $qb->getQuery();
    }

    /**
     * Find Series field by EmbeddedBroadcast type.
     *
     * @param string $type
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return mixed
     */
    public function findSeriesFieldByEmbeddedBroadcastType($type = '', $sort = [], $limit = 0, $page = 0)
    {
        $query = $this->findSeriesFieldByEmbeddedBroadcastTypeQuery($type, $sort, $limit, $page);

        return $query->execute();
    }

    /**
     * Find series field with embedded broadcast type and groups Query Builder.
     *
     * @param string $type
     * @param array  $groups
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return \Doctrine\MongoDB\Query\Builder|mixed
     */
    public function findSeriesFieldByEmbeddedBroadcastTypeAndGroupsQueryBuilder($type = '', $groups = [], $sort = [], $limit = 0, $page = 0)
    {
        $groupsIds = $this->getGroupsIdsArray($groups);

        $qb = $this->findByEmbeddedBroadcastTypeQueryBuilder($type)->field('embeddedBroadcast.groups')->all($groupsIds)->field('embeddedBroadcast.groups')->size(count($groupsIds))->distinct('series');

        return $this->addSortAndLimitToQueryBuilder($qb, $sort, $limit, $page);
    }

    /**
     * Find series field with embedded broadcast type and groups Query.
     *
     * @param string $type
     * @param array  $groups
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return \Doctrine\MongoDB\Query\Query
     */
    public function findSeriesFieldByEmbeddedBroadcastTypeAndGroupsQuery($type = '', $groups = [], $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->findSeriesFieldByEmbeddedBroadcastTypeAndGroupsQueryBuilder($type, $groups, $sort, $limit, $page);

        return $qb->getQuery();
    }

    /**
     * Find series field with embedded broadcast type and groups.
     *
     * @param string $type
     * @param array  $groups
     * @param array  $sort
     * @param int    $limit
     * @param int    $page
     *
     * @return \Doctrine\MongoDB\Query\Query
     */
    public function findSeriesFieldByEmbeddedBroadcastTypeAndGroups($type = '', $groups = [], $sort = [], $limit = 0, $page = 0)
    {
        $query = $this->findSeriesFieldByEmbeddedBroadcastTypeAndGroupsQuery($type, $groups, $sort, $limit, $page);

        return $query->execute();
    }

    /**
     * @param mixed $groups
     *
     * @return array
     */
    public function getGroupsIdsArray($groups)
    {
        $groupsIds = [];
        if ($groups) {
            if ('array' !== gettype($groups)) {
                $groups = $groups->toArray();
                $groupsIds = $this->getMongoIds($groups);
            } else {
                $mockString = false;
                $mockGroup = false;
                foreach ($groups as $group) {
                    if ('string' === gettype($group)) {
                        $mockString = true;

                        break;
                    }
                    if ($group instanceof Group) {
                        $mockGroup = true;

                        break;
                    }
                }
                if ($mockString) {
                    foreach ($groups as $group) {
                        $groupsIds[] = new ObjectId($group);
                    }
                } elseif ($mockGroup) {
                    $groupsIds = $this->getMongoIds($groups);
                } else {
                    $groupsIds = $groups;
                }
            }
        }

        return $groupsIds;
    }

    /**
     * @deprecated
     * Use findNextSessions of EmbeddedEventSessionService
     *
     * @param string $multimediaObjectId
     *
     * @throws \Doctrine\ODM\MongoDB\MongoDBException
     *
     * @return array
     */
    public function findNextEventSessions($multimediaObjectId)
    {
        $dm = $this->getDocumentManager();
        $collection = $dm->getDocumentCollection(MultimediaObject::class);

        $pipeline[] = [
            '$match' => [
                '_id' => new ObjectId($multimediaObjectId),
                'type' => MultimediaObject::TYPE_LIVE,
                'embeddedEvent.embeddedEventSession' => ['$exists' => true],
            ],
        ];

        $pipeline[] = [
            '$project' => [
                'multimediaObjectId' => '$_id',
                'event' => '$embeddedEvent',
                'sessions' => '$embeddedEvent.embeddedEventSession',
                'pics' => '$pics',
            ],
        ];

        $pipeline[] = ['$unwind' => '$sessions'];

        $pipeline[] = [
            '$match' => [
                '$and' => [
                    ['sessions.start' => ['$exists' => true]],
                    ['sessions.start' => ['$gt' => new UTCDateTime()]],
                ],
            ],
        ];

        $pipeline[] = [
            '$project' => [
                'multimediaObjectId' => '$multimediaObjectId',
                'event' => '$event',
                'pics' => '$pics',
                'session' => '$sessions',
            ],
        ];

        $pipeline[] = [
            '$group' => [
                '_id' => '$multimediaObjectId',
                'data' => [
                    '$addToSet' => [
                        'event' => '$event',
                        'session' => '$session',
                        'multimediaObjectId' => '$multimediaObjectId',
                        'pics' => '$pics',
                    ],
                ],
            ],
        ];

        $result = $collection->aggregate($pipeline, ['cursor' => []])->toArray();

        foreach ($result as $key => $element) {
            $orderSession = [];
            foreach ($element['data'] as $eventData) {
                $seconds = $eventData['session']['start']->toDateTime()->format('U');
                $orderSession[$seconds] = $eventData;
            }
            ksort($orderSession);
            $result[$key]['data'] = array_values($orderSession);
        }

        return $result;
    }

    /**
     * @deprecated
     * Use findCurrentSessions of EmbeddedEventSessionService
     *
     * @param \MongoId|string|null $multimediaObjectId
     * @param int                  $limit
     *
     * @throws \Doctrine\ODM\MongoDB\MongoDBException
     *
     * @return array
     */
    public function findNowEventSessions($multimediaObjectId = null, $limit = 0)
    {
        $dm = $this->getDocumentManager();
        $collection = $dm->getDocumentCollection(MultimediaObject::class);

        if ($multimediaObjectId) {
            $pipeline[] = [
                '$match' => [
                    '_id' => new ObjectId($multimediaObjectId),
                    'type' => MultimediaObject::TYPE_LIVE,
                    'embeddedEvent.embeddedEventSession' => ['$exists' => true],
                ],
            ];
        } else {
            $pipeline[] = [
                '$match' => [
                    'type' => MultimediaObject::TYPE_LIVE,
                    'embeddedEvent.display' => true,
                    'embeddedEvent.embeddedEventSession' => ['$exists' => true],
                ],
            ];
        }

        $pipeline[] = [
            '$project' => [
                'multimediaObjectId' => '$_id',
                'event' => '$embeddedEvent',
                'sessions' => '$embeddedEvent.embeddedEventSession',
            ],
        ];

        $pipeline[] = ['$unwind' => '$sessions'];

        $pipeline[] = [
            '$project' => [
                'multimediaObjectId' => '$multimediaObjectId',
                'event' => '$event',
                'sessions' => '$sessions',
                'sessionEnds' => [
                    '$add' => [
                        '$sessions.start',
                        [
                            '$multiply' => [
                                '$sessions.duration',
                                1000,
                            ],
                        ],
                    ],
                ],
            ],
        ];

        $pipeline[] = [
            '$match' => [
                'sessions.start' => ['$lt' => new UTCDateTime()],
                'sessionEnds' => ['$gt' => new UTCDateTime()],
            ],
        ];

        $pipeline[] = [
            '$project' => [
                'multimediaObjectId' => '$multimediaObjectId',
                'event' => '$event',
                'sessions' => '$sessions',
                'session' => '$sessions',
                'sessionEnds' => '$sessionEnds',
            ],
        ];

        $pipeline[] = [
            '$group' => [
                '_id' => '$multimediaObjectId',
                'data' => [
                    '$addToSet' => [
                        'event' => '$event',
                        'session' => '$session',
                        'multimediaObjectId' => '$multimediaObjectId',
                        'sessionEnds' => '$sessionEnds',
                    ],
                ],
            ],
        ];

        if ($limit > 0) {
            $pipeline[] = ['$limit' => $limit];
        }

        return $collection->aggregate($pipeline, ['cursor' => []])->toArray();
    }

    /**
     * Count number of multimedia objects by series.
     *
     * @param array $seriesList
     *
     * @throws \Doctrine\ODM\MongoDB\MongoDBException
     *
     * @return array() A key/value hash where the key is the series id (string) and the value is the count
     * @return array
     */
    public function countMmobjsBySeries($seriesList = [])
    {
        $dm = $this->getDocumentManager();

        $multimediaObjectsColl = $dm->getDocumentCollection(MultimediaObject::class);

        $criteria = $this->dm->getFilterCollection()->getFilterCriteria($this->getClassMetadata());
        if ($seriesList) {
            $seriesIds = [];
            foreach ($seriesList as $series) {
                $seriesIds[] = new ObjectId($series->getId());
            }

            $criteria['series'] = ['$in' => $seriesIds];
        }

        $pipeline = [
            ['$match' => $criteria],
            ['$group' => ['_id' => '$series', 'count' => ['$sum' => 1]]],
        ];

        $aggregation = $multimediaObjectsColl->aggregate($pipeline, ['cursor' => []]);
        $mmobjCount = [];

        foreach ($aggregation as $a) {
            $mmobjCount[(string) $a['_id']] = $a['count'];
        }

        return $mmobjCount;
    }

    /**
     * Count number of multimedia objects by tags.
     *
     * @param array $tagCodsList
     *
     * @throws \Doctrine\ODM\MongoDB\MongoDBException
     *
     * @return array() A key/value hash where the key is the tag cod (string) and the value is the count
     * @return array
     */
    public function countMmobjsByTagCods($tagCodsList = [])
    {
        $dm = $this->getDocumentManager();

        $multimediaObjectsColl = $dm->getDocumentCollection(MultimediaObject::class);

        $pipeline = [
            ['$project' => ['_id' => '$tags.cod']],
            ['$unwind' => '$_id'],
            ['$group' => ['_id' => '$_id', 'count' => ['$sum' => 1]]],
        ];

        $criteria = $this->dm->getFilterCollection()->getFilterCriteria($this->getClassMetadata());
        if ($criteria) {
            $preCriteria = ['$match' => $criteria];
            array_unshift($pipeline, $preCriteria);
        }

        if ($tagCodsList) {
            $preCriteria = ['$match' => ['tags.cod' => ['$in' => $tagCodsList]]];
            array_unshift($pipeline, $preCriteria);
        }

        $aggregation = $multimediaObjectsColl->aggregate($pipeline, ['cursor' => []]);
        $mmobjCount = [];

        foreach ($aggregation as $a) {
            $mmobjCount[(string) $a['_id']] = $a['count'];
        }

        return $mmobjCount;
    }

    /**
     * Get mongo ids.
     *
     * @return array
     */
    private function getMongoIds(array $documents)
    {
        $mongoIds = [];
        foreach ($documents as $document) {
            $mongoIds[] = new ObjectId($document->getId());
        }

        return $mongoIds;
    }

    /**
     * Add limit (and page) to Query Builder.
     *
     * @param Builder $qb
     * @param int     $limit
     * @param int     $page
     *
     * @return mixed
     */
    private function addLimitToQueryBuilder($qb, $limit = 0, $page = 0)
    {
        if ($limit > 0) {
            $qb->limit($limit)->skip($limit * $page);
        }

        return $qb;
    }

    /**
     * Add sort to Query Builder.
     *
     * @param Builder $qb
     * @param array   $sort
     *
     * @return mixed
     */
    private function addSortToQueryBuilder($qb, $sort = [])
    {
        if (0 !== count($sort)) {
            $qb->sort($sort);
        }

        return $qb;
    }

    /**
     * Add sort and limit (and page) to Query Builder.
     *
     * @param Builder $qb
     * @param array   $sort
     * @param int     $limit
     * @param int     $page
     *
     * @return mixed
     */
    private function addSortAndLimitToQueryBuilder($qb, $sort = [], $limit = 0, $page = 0)
    {
        $qb = $this->addSortToQueryBuilder($qb, $sort);

        return $this->addLimitToQueryBuilder($qb, $limit, $page);
    }
}
